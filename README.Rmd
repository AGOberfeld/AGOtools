---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
require(AGOtools)
require(tidyverse)
require(quickpsy)
```

# AGOtools

<!-- badges: start -->
<!-- badges: end -->

AGOtools is an R package providing some useful tools for the analysis of empirical data (plot themes for publication-ready plots using R's ggplot, outlier detection using a Tukey criterion, helper functions for fitting psychometric functions with the R package quickpsy (https://github.com/danilinares/quickpsy) etc.).

## Project Status

This Project is currently under construction. 

## Installation

Install AGOtools with:

```
devtools::install_github("AGOberfeld/AGOtools")
```

## Dependencies

Before using AGOtools, make sure the right Quickpsy-version (dev-verion from Github, https://github.com/danilinares/quickpsy) is installed:

```
devtools::install_github("danilinares/quickpsy")
```


If you have already installed the official version from CRAN, remove quickpsy before installing it again from github.

```
remove.packages("quickpsy")

# install.packages("devtools")
require(devtools)
devtools::install_github("danilinares/quickpsy")

```

## Functions

### set_options

Sets the color palette of ggplots to default values. By default the matplotlib colors are chosen. Also sets the number format for the R output and loads some default packages (`tidyverse`, `pracma`, `extrafont`).

```{r, echo =TRUE}
set_options()
```


### tukey

Adds variables to an input dataset (data) which indicate if observations on a specified variable (dv) are outliers according to a "nonparametric"  criterion proposed by John Tukey. Values of variable dv more than k`*`IQR (interquartile range) below the first quartile (25% quantile) or more than k`*`IQR above the third quartile (75% quantile) are flagged as outliers.
The argument tukey_crit can be used to modify the factor k (default = 3).

Identify outliers without excluding them:
```{r, echo =TRUE}
tukey(data = loudness_block, 
      dv = Estimated_TTC, 
      tukey_crit=3, 
      exclude = FALSE)
```

Identify outliers and exclude them:
```{r, echo =TRUE}
loudness_block %>%
	tukey(Estimated_TTC, 
	      exclude = TRUE)
```

Outlier exclusion groupwise:
```{r, echo =TRUE}
loudness_block %>% 
  group_by(Condition, Car_label, GaindB,loudnessVariation) %>% 
  tukey(Estimated_TTC, 
	      exclude = TRUE)
```


Returns a list of variables and adds them to the initial data set:

`trialsInSet` = total number of trials in the data set  
`IQR` = inter quantile range  
`Quant25` = 25% quantile  
`Quant75` = 75% quantile  
`outlierTukeyLow` = indicates if dv for a given trial is lower than the tukey criterion (1) or not (0)  
`outlierTukeyHigh` = indicates if dv for a given trial is higher than the tukey criterion (1) or not (0)   
`outlierTukey` = indicates if dv for a given trial exceeds the lower or the higher criterion (1) or is within both criteria (0)  
`Tukey_lower_limit` = highest value above which values are excluded  
`Tukey_upper_limit` = lowest value below which values are excluded  


### tidyQuickPsy

This function is used to facilitate the analysis of psychometric functions fitted with quickpsy (https://github.com/danilinares/quickpsy).

Takes a quickpsy-object and turns it as a tibble.

Use the following arguments in the quickpsy function:   
`d` = data  
`x` = Name of the explanatory variable (e.g. TTC)  
`k` = Name of the variable containing the number of "positive" decisions per group (= unique combination of the grouping variables) 
`n` = Name of the variable containing the number of trials per group (= unique combination of the grouping variables) 
`grouping` = concatinated vector of the variables that define the groups of trials (i.e., rows in the input dataset) to which separate psychometric functions are fit (e.g., a vector containing the participant code variable and the variables defining separate experimental conditions) 


```{r, warning=FALSE, echo =TRUE}
data <- streetcrossing %>% 
  filter(vp_code == "vp0001")

qp <- quickpsy(d = data,  
                x = track_TTC, 
                k = nCross, 
                n = nTrials,  
                grouping = c("vp_code","modality","v0","a","label","gain"),  
                fun=cum_normal_fun,  
                guess=0,  
                lapses=0,  
                bootstrap = 'none')  

qp_tidy <- tidyQuickPsy(qp)

qp_tidy$tidy_fit %>% 
  head()
```

tidyQuickPsy returns a list with two elements:  
-   `qp_tidy$qp` is the "old" quickpsy object
-   `qp_tidy$tidy_fit` is a tidy tibble containing the most important statistics of the quickpsy object.





### plotQuickPsy

Takes an object produced by tidyQuickPsy and plots the resulting psychometric functions for each person separately.

```{r, warning=FALSE, echo =TRUE}
qp_tidy <- tidyQuickPsy(qp)

plotQuickPsy(qp_tidy)$plot_list[[1]]

```

If the hessian matrix for one participant is not solvable, use this workaround to loop through all participant-condition combinations:

```{r, eval=FALSE, echo = TRUE}
# load data
data <- streetcrossing

# split by conditions and participant ID
data_list <- data %>% 
  group_split(vp_code,modality,v0,a,label,gain)

qp_list <- list()
df_list <- list()

# safe quickpsy execution
for(i in seq_along(data_list)){
  qp_list[[i]] <- tryCatch(tidyQuickPsy(quickpsy(d = data_list[[i]],
                           x = track_TTC,
                           k = nCross,
                           n = nTrials,
                           grouping = c("vp_code","modality","v0","a","label","gain"),
                           bootstrap = 'none')),
                           
                           warning = function(w){print(w)},
                           
                           error = function(e){e},
                           
                           finally = "finished")
  
  # tidy dfs
  df_list[[i]] <- qp_list[[i]]$tidy_fit
  
  status_message <- paste(round(i/length(data_list),4)*100,"% completed")
  print(status_message)
  if(rlang::is_error(qp_list[[i]])){
    print(paste("Error in data_list-element Nr.",i))
  }
}

# Filter List for errors
qp_list_clean <- qp_list[!sapply(qp_list, rlang::is_error)]
df_list_clean <- df_list[!sapply(df_list, rlang::is_error)]

# row bind data frame

df <- df_list_clean %>% 
  bind_rows()

# plot list

plot_list <- list()

for(i in seq_along(qp_list_clean)){
  plot_list[[i]] <- plotQuickPsy(qp_list_clean[[i]])$plot_list[[1]]

  status_message <- paste(round(i/length(qp_list_clean),2)*100,"% completed")
  print(status_message)
}
```
### plotThemeAGO

Plot theme for publication-ready data plots.

```{r, warning=FALSE, echo =TRUE}
dat_clean <- loudness_block %>%
  tukey(Estimated_TTC, 
        exclude = T) %>% 
  mutate(TTC_as_factor = factor(TTC),
         Condition_text = str_c(GaindB," dB, ",loudnessVariation)) %>% 
  group_by(Participantnr, TTC, TTC_as_factor, Velocity, Condition_text, loudnessVariation, GaindB) %>% 
  summarise(mean_estTTC = mean(Estimated_TTC), 
            SD_estTTC = sd(Estimated_TTC),
            N_estTTC = n())

sum_dat <- dat_clean %>%
   filter(Participantnr != "vp001") %>% 
   group_by(TTC, TTC_as_factor, Velocity, GaindB, loudnessVariation, Condition_text) %>%
   summarise(mean_estTTC_mean = mean(mean_estTTC), SD_estTTC_mean = sd(mean_estTTC)) 

dat_clean %>%
  filter(Participantnr != "vp001") %>% 
  ggplot(aes(x = TTC, 
             y = mean_estTTC, 
             color = as.factor(GaindB),
             shape = as.factor(loudnessVariation), 
             linetype = as.factor(loudnessVariation)))+
  geom_abline(aes(intercept=0, slope =1), 
              color = "grey")+
  geom_line(data = sum_dat, 
            aes(x = TTC, 
                y = mean_estTTC_mean), 
            linewidth = 1, 
            show.legend = FALSE)+
  stat_summary_bin(fun.data = mean_se, 
                   geom = "errorbar", 
                   linewidth = 1, 
                   alpha = 0.7, 
                   show.legend = FALSE)+
  stat_summary_bin(fun = mean, 
                   geom = "point", 
                   alpha = 0.9,
                   size = 3, 
                   show.legend = TRUE)+
  geom_jitter(alpha = 0.1, 
              width = 0.3, 
              show.legend = FALSE)+
  coord_cartesian(xlim = c(0,6), 
                  ylim = c(0,6))+
  facet_wrap(vars(Velocity))+
  plotThemeAGO(base_size = 14)+
  labs(x = "Presented TTC [s]", 
       y = "Estimated TTC [s]", 
       colour = "Gain (dB)", 
       shape = "", 
       linetype="")+
  theme(aspect.ratio = 1)
```


### Data sets


```{r, echo =TRUE}
data("loudness_block")
head(loudness_block)

data("streetcrossing")
head(streetcrossing)
```

